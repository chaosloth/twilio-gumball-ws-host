{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useSocketIO = void 0;\n\nvar react_1 = require(\"react\");\n\nvar use_websocket_1 = require(\"./use-websocket\");\n\nvar constants_1 = require(\"./constants\");\n\nvar emptyEvent = {\n  type: 'empty',\n  payload: null\n};\n\nvar getSocketData = function (event) {\n  if (!event || !event.data) {\n    return emptyEvent;\n  }\n\n  var match = event.data.match(/\\[.*]/);\n\n  if (!match) {\n    return emptyEvent;\n  }\n\n  var data = JSON.parse(match);\n\n  if (!Array.isArray(data) || !data[1]) {\n    return emptyEvent;\n  }\n\n  return {\n    type: data[0],\n    payload: data[1]\n  };\n};\n\nexports.useSocketIO = function (url, options, connect) {\n  if (options === void 0) {\n    options = constants_1.DEFAULT_OPTIONS;\n  }\n\n  if (connect === void 0) {\n    connect = true;\n  }\n\n  var optionsWithSocketIO = react_1.useMemo(function () {\n    return __assign(__assign({}, options), {\n      fromSocketIO: true\n    });\n  }, []);\n\n  var _a = use_websocket_1.useWebSocket(url, optionsWithSocketIO, connect),\n      sendMessage = _a.sendMessage,\n      sendJsonMessage = _a.sendJsonMessage,\n      lastMessage = _a.lastMessage,\n      readyState = _a.readyState,\n      getWebSocket = _a.getWebSocket;\n\n  var socketIOLastMessage = react_1.useMemo(function () {\n    return getSocketData(lastMessage);\n  }, [lastMessage]);\n  return {\n    sendMessage: sendMessage,\n    sendJsonMessage: sendJsonMessage,\n    lastMessage: socketIOLastMessage,\n    lastJsonMessage: socketIOLastMessage,\n    readyState: readyState,\n    getWebSocket: getWebSocket\n  };\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAQA,IAAMA,UAAU,GAAwB;AACtCC,MAAI,EAAE,OADgC;AAEtCC,SAAO,EAAE;AAF6B,CAAxC;;AAKA,IAAMC,aAAa,GAAG,UAACC,KAAD,EAA2C;AAC/D,MAAI,CAACA,KAAD,IAAU,CAACA,KAAK,CAACC,IAArB,EAA2B;AACzB,WAAOL,UAAP;AACD;;AAED,MAAMM,KAAK,GAAGF,KAAK,CAACC,IAAN,CAAWC,KAAX,CAAiB,OAAjB,CAAd;;AAEA,MAAI,CAACA,KAAL,EAAY;AACV,WAAON,UAAP;AACD;;AAED,MAAMK,IAAI,GAAGE,IAAI,CAACC,KAAL,CAAWF,KAAX,CAAb;;AAEA,MAAI,CAACG,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAD,IAAwB,CAACA,IAAI,CAAC,CAAD,CAAjC,EAAsC;AACpC,WAAOL,UAAP;AACD;;AAED,SAAO;AACLC,QAAI,EAAEI,IAAI,CAAC,CAAD,CADL;AAELH,WAAO,EAAEG,IAAI,CAAC,CAAD;AAFR,GAAP;AAID,CArBD;;AAuBaM,sBAAc,UACzBC,GADyB,EAEzBC,OAFyB,EAGzBC,OAHyB,EAGF;AADvB;AAAAD,cAAmBE,2BAAnB;AAAkC;;AAClC;AAAAD;AAAuB;;AAEvB,MAAME,mBAAmB,GAAGC,gBAAQ;AAAM,iCACrCJ,OADqC,GAC9B;AACVK,kBAAY,EAAE;AADJ,KAD8B;AAGxC,GAH0B,EAGxB,EAHwB,CAA5B;;AAKM,WAMFC,6BAEFP,GAFE,EAGFI,mBAHE,EAIFF,OAJE,CANE;AAAA,MACJM,WAAW,iBADP;AAAA,MAEJC,eAAe,qBAFX;AAAA,MAGJC,WAAW,iBAHP;AAAA,MAIJC,UAAU,gBAJN;AAAA,MAKJC,YAAY,kBALR;;AAaN,MAAMC,mBAAmB,GAAGR,gBAAQ;AAClC,wBAAa,CAACK,WAAD,CAAb;AAA0B,GADA,EACE,CAACA,WAAD,CADF,CAA5B;AAGA,SAAO;AACLF,eAAW,aADN;AAELC,mBAAe,iBAFV;AAGLC,eAAW,EAAEG,mBAHR;AAILC,mBAAe,EAAED,mBAJZ;AAKLF,cAAU,YALL;AAMLC,gBAAY;AANP,GAAP;AAQD,CAlCY","names":["emptyEvent","type","payload","getSocketData","event","data","match","JSON","parse","Array","isArray","exports","url","options","connect","constants_1","optionsWithSocketIO","react_1","fromSocketIO","use_websocket_1","sendMessage","sendJsonMessage","lastMessage","readyState","getWebSocket","socketIOLastMessage","lastJsonMessage"],"sources":["/Users/charland/Documents/GitHub/twilio-gumball-ws-host/node_modules/react-use-websocket/src/lib/use-socket-io.ts"],"sourcesContent":["import { useMemo } from 'react'\nimport { useWebSocket } from './use-websocket'\nimport { DEFAULT_OPTIONS } from './constants'\nimport { Options, WebSocketHook } from './types';\n\nexport interface SocketIOMessageData {\n  type: string,\n  payload: any,\n}\n\nconst emptyEvent: SocketIOMessageData = {\n  type: 'empty',\n  payload: null,\n}\n\nconst getSocketData = (event: WebSocketEventMap['message'] | null): SocketIOMessageData => {\n  if (!event || !event.data) {\n    return emptyEvent\n  }\n\n  const match = event.data.match(/\\[.*]/)\n\n  if (!match) {\n    return emptyEvent\n  }\n\n  const data = JSON.parse(match)\n\n  if (!Array.isArray(data) || !data[1]) {\n    return emptyEvent\n  }\n\n  return {\n    type: data[0],\n    payload: data[1],\n  }\n}\n\nexport const useSocketIO = (\n  url: string | (() => string | Promise<string>) | null,\n  options: Options = DEFAULT_OPTIONS,\n  connect: boolean = true,\n): WebSocketHook<SocketIOMessageData> => {\n  const optionsWithSocketIO = useMemo(() => ({\n    ...options,\n    fromSocketIO: true,\n  }), [])\n\n  const {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage,\n    readyState,\n    getWebSocket,\n  } = useWebSocket(\n\n    url,\n    optionsWithSocketIO,\n    connect,\n  );\n\n  const socketIOLastMessage = useMemo(() =>\n    getSocketData(lastMessage), [lastMessage]);\n\n  return {\n    sendMessage,\n    sendJsonMessage,\n    lastMessage: socketIOLastMessage,\n    lastJsonMessage: socketIOLastMessage,\n    readyState,\n    getWebSocket,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}