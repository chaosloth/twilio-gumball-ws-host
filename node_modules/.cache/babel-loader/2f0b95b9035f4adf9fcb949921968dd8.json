{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createOrJoinSocket = void 0;\n\nvar globals_1 = require(\"./globals\");\n\nvar constants_1 = require(\"./constants\");\n\nvar attach_listener_1 = require(\"./attach-listener\");\n\nvar attach_shared_listeners_1 = require(\"./attach-shared-listeners\");\n\nvar manage_subscribers_1 = require(\"./manage-subscribers\"); //TODO ensure that all onClose callbacks are called\n\n\nvar cleanSubscribers = function (url, subscriber, optionsRef, setReadyState, clearSocketIoPingInterval) {\n  return function () {\n    manage_subscribers_1.removeSubscriber(url, subscriber);\n\n    if (!manage_subscribers_1.hasSubscribers(url)) {\n      try {\n        var socketLike = globals_1.sharedWebSockets[url];\n\n        if (socketLike instanceof WebSocket) {\n          socketLike.onclose = function (event) {\n            if (optionsRef.current.onClose) {\n              optionsRef.current.onClose(event);\n            }\n\n            setReadyState(constants_1.ReadyState.CLOSED);\n          };\n        }\n\n        socketLike.close();\n      } catch (e) {}\n\n      if (clearSocketIoPingInterval) clearSocketIoPingInterval();\n      delete globals_1.sharedWebSockets[url];\n    }\n  };\n};\n\nexports.createOrJoinSocket = function (webSocketRef, url, setReadyState, optionsRef, setLastMessage, startRef, reconnectCount, sendMessage) {\n  if (!constants_1.isEventSourceSupported && optionsRef.current.eventSourceOptions) {\n    if (constants_1.isReactNative) {\n      throw new Error('EventSource is not supported in ReactNative');\n    } else {\n      throw new Error('EventSource is not supported');\n    }\n  }\n\n  if (optionsRef.current.share) {\n    var clearSocketIoPingInterval = null;\n\n    if (globals_1.sharedWebSockets[url] === undefined) {\n      globals_1.sharedWebSockets[url] = optionsRef.current.eventSourceOptions ? new EventSource(url, optionsRef.current.eventSourceOptions) : new WebSocket(url, optionsRef.current.protocols);\n      webSocketRef.current = globals_1.sharedWebSockets[url];\n      setReadyState(constants_1.ReadyState.CONNECTING);\n      clearSocketIoPingInterval = attach_shared_listeners_1.attachSharedListeners(globals_1.sharedWebSockets[url], url, optionsRef, sendMessage);\n    } else {\n      webSocketRef.current = globals_1.sharedWebSockets[url];\n      setReadyState(globals_1.sharedWebSockets[url].readyState);\n    }\n\n    var subscriber = {\n      setLastMessage: setLastMessage,\n      setReadyState: setReadyState,\n      optionsRef: optionsRef,\n      reconnectCount: reconnectCount,\n      reconnect: startRef\n    };\n    manage_subscribers_1.addSubscriber(url, subscriber);\n    return cleanSubscribers(url, subscriber, optionsRef, setReadyState, clearSocketIoPingInterval);\n  } else {\n    webSocketRef.current = optionsRef.current.eventSourceOptions ? new EventSource(url, optionsRef.current.eventSourceOptions) : new WebSocket(url, optionsRef.current.protocols);\n    setReadyState(constants_1.ReadyState.CONNECTING);\n\n    if (!webSocketRef.current) {\n      throw new Error('WebSocket failed to be created');\n    }\n\n    return attach_listener_1.attachListeners(webSocketRef.current, {\n      setLastMessage: setLastMessage,\n      setReadyState: setReadyState\n    }, optionsRef, startRef.current, reconnectCount, sendMessage);\n  }\n};","map":{"version":3,"mappings":"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","names":["cleanSubscribers","url","subscriber","optionsRef","setReadyState","clearSocketIoPingInterval","manage_subscribers_1","socketLike","globals_1","WebSocket","onclose","event","current","onClose","constants_1","CLOSED","close","e","exports","webSocketRef","setLastMessage","startRef","reconnectCount","sendMessage","eventSourceOptions","Error","share","undefined","EventSource","protocols","CONNECTING","attach_shared_listeners_1","readyState","reconnect","attach_listener_1"],"sources":["/Users/charland/Documents/GitHub/twilio-gumball-ws-host/node_modules/react-use-websocket/src/lib/create-or-join.ts"],"sourcesContent":["import { MutableRefObject } from 'react';\nimport { sharedWebSockets } from './globals';\nimport { Options, SendMessage, Subscriber, WebSocketLike } from './types';\nimport { isEventSourceSupported, ReadyState, isReactNative } from './constants';\nimport { attachListeners } from './attach-listener';\nimport { attachSharedListeners } from './attach-shared-listeners';\nimport { addSubscriber, removeSubscriber, hasSubscribers } from './manage-subscribers';\n\n//TODO ensure that all onClose callbacks are called\n\nconst cleanSubscribers = (\n  url: string,\n  subscriber: Subscriber,\n  optionsRef: MutableRefObject<Options>,\n  setReadyState: (readyState: ReadyState) => void,\n  clearSocketIoPingInterval: (() => void) | null,\n) => {\n  return () => {\n    removeSubscriber(url, subscriber);\n    if (!hasSubscribers(url)) {\n      try {\n        const socketLike = sharedWebSockets[url];\n        if (socketLike instanceof WebSocket) {\n          socketLike.onclose = (event: WebSocketEventMap['close']) => {\n            if (optionsRef.current.onClose) {\n              optionsRef.current.onClose(event);\n            }\n            setReadyState(ReadyState.CLOSED);\n          };\n        }\n        socketLike.close();\n      } catch (e) {\n\n      }\n      if (clearSocketIoPingInterval) clearSocketIoPingInterval();\n\n      delete sharedWebSockets[url];\n    }\n  }\n};\n\nexport const createOrJoinSocket = (\n  webSocketRef: MutableRefObject<WebSocketLike | null>,\n  url: string,\n  setReadyState: (readyState: ReadyState) => void,\n  optionsRef: MutableRefObject<Options>,\n  setLastMessage: (message: WebSocketEventMap['message']) => void,\n  startRef: MutableRefObject<() => void>,\n  reconnectCount: MutableRefObject<number>,\n  sendMessage: SendMessage,\n): (() => void) => {\n  if (!isEventSourceSupported && optionsRef.current.eventSourceOptions) {\n    if (isReactNative) {\n      throw new Error('EventSource is not supported in ReactNative');\n    } else {\n      throw new Error('EventSource is not supported');\n    }\n  }\n\n  if (optionsRef.current.share) {\n    let clearSocketIoPingInterval: ((() => void) | null) = null;\n    if (sharedWebSockets[url] === undefined) {\n      sharedWebSockets[url] = optionsRef.current.eventSourceOptions ?\n        new EventSource(url, optionsRef.current.eventSourceOptions) :\n        new WebSocket(url, optionsRef.current.protocols);\n      webSocketRef.current = sharedWebSockets[url];\n      setReadyState(ReadyState.CONNECTING);\n      clearSocketIoPingInterval = attachSharedListeners(\n        sharedWebSockets[url],\n        url,\n        optionsRef,\n        sendMessage,\n      );\n    } else {\n      webSocketRef.current = sharedWebSockets[url];\n      setReadyState(sharedWebSockets[url].readyState);\n    }\n\n    const subscriber: Subscriber = {\n      setLastMessage,\n      setReadyState,\n      optionsRef,\n      reconnectCount,\n      reconnect: startRef,\n    };\n  \n    addSubscriber(url, subscriber);\n\n    return cleanSubscribers(\n      url,\n      subscriber,\n      optionsRef,\n      setReadyState,\n      clearSocketIoPingInterval,\n    );\n  } else {\n    webSocketRef.current = optionsRef.current.eventSourceOptions ?\n      new EventSource(url, optionsRef.current.eventSourceOptions) :\n      new WebSocket(url, optionsRef.current.protocols);\n    setReadyState(ReadyState.CONNECTING);\n    if (!webSocketRef.current) {\n      throw new Error('WebSocket failed to be created');\n    }\n\n    return attachListeners(\n      webSocketRef.current,\n      {\n        setLastMessage,\n        setReadyState\n      },\n      optionsRef,\n      startRef.current,\n      reconnectCount,\n      sendMessage,\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"script"}