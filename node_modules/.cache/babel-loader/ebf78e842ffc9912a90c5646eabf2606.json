{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.attachSharedListeners = void 0;\n\nvar globals_1 = require(\"./globals\");\n\nvar constants_1 = require(\"./constants\");\n\nvar manage_subscribers_1 = require(\"./manage-subscribers\");\n\nvar socket_io_1 = require(\"./socket-io\");\n\nvar bindMessageHandler = function (webSocketInstance, url) {\n  webSocketInstance.onmessage = function (message) {\n    manage_subscribers_1.getSubscribers(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (typeof subscriber.optionsRef.current.filter === 'function' && subscriber.optionsRef.current.filter(message) !== true) {\n        return;\n      }\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nvar bindOpenHandler = function (webSocketInstance, url) {\n  webSocketInstance.onopen = function (event) {\n    manage_subscribers_1.getSubscribers(url).forEach(function (subscriber) {\n      subscriber.reconnectCount.current = 0;\n\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(constants_1.ReadyState.OPEN);\n    });\n  };\n};\n\nvar bindCloseHandler = function (webSocketInstance, url) {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = function (event) {\n      manage_subscribers_1.getSubscribers(url).forEach(function (subscriber) {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      });\n      delete globals_1.sharedWebSockets[url];\n      manage_subscribers_1.getSubscribers(url).forEach(function (subscriber) {\n        var _a, _b;\n\n        if (subscriber.optionsRef.current.shouldReconnect && subscriber.optionsRef.current.shouldReconnect(event)) {\n          var reconnectAttempts = (_a = subscriber.optionsRef.current.reconnectAttempts) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_LIMIT;\n\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            setTimeout(function () {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, (_b = subscriber.optionsRef.current.reconnectInterval) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts);\n            console.warn(\"Max reconnect attempts of \" + reconnectAttempts + \" exceeded\");\n          }\n        }\n      });\n    };\n  }\n};\n\nvar bindErrorHandler = function (webSocketInstance, url) {\n  webSocketInstance.onerror = function (error) {\n    manage_subscribers_1.getSubscribers(url).forEach(function (subscriber) {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n\n      if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose(__assign(__assign({}, error), {\n          code: 1006,\n          reason: \"An error occurred with the EventSource: \" + error,\n          wasClean: false\n        }));\n        subscriber.setReadyState(constants_1.ReadyState.CLOSED);\n      }\n    });\n\n    if (constants_1.isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexports.attachSharedListeners = function (webSocketInstance, url, optionsRef, sendMessage) {\n  var interval;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = socket_io_1.setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n  return function () {\n    if (interval) clearInterval(interval);\n  };\n};","map":{"version":3,"mappings":"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","names":["bindMessageHandler","webSocketInstance","url","onmessage","message","manage_subscribers_1","forEach","subscriber","optionsRef","current","onMessage","filter","setLastMessage","bindOpenHandler","onopen","event","reconnectCount","onOpen","setReadyState","constants_1","OPEN","bindCloseHandler","WebSocket","onclose","onClose","CLOSED","globals_1","shouldReconnect","reconnectAttempts","_a","setTimeout","reconnect","reconnectInterval","_b","onReconnectStop","console","warn","bindErrorHandler","onerror","error","onError","EventSource","__assign","code","reason","wasClean","close","exports","sendMessage","interval","fromSocketIO","socket_io_1","clearInterval"],"sources":["/Users/charland/Documents/GitHub/twilio-gumball-ws-host/node_modules/react-use-websocket/src/lib/attach-shared-listeners.ts"],"sourcesContent":["import { sharedWebSockets } from './globals';\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState, isEventSourceSupported } from './constants';\nimport { getSubscribers } from './manage-subscribers';\nimport { MutableRefObject } from 'react';\nimport { Options, SendMessage, WebSocketLike } from './types';\nimport { setUpSocketIOPing } from './socket-io';\n\nconst bindMessageHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onMessage) {\n        subscriber.optionsRef.current.onMessage(message);\n      }\n\n      if (\n        typeof subscriber.optionsRef.current.filter === 'function' &&\n        subscriber.optionsRef.current.filter(message) !== true\n      ) {\n        return;\n      }\n\n      subscriber.setLastMessage(message);\n    });\n  };\n};\n\nconst bindOpenHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onopen = (event: WebSocketEventMap['open']) => {\n    getSubscribers(url).forEach(subscriber => {\n      subscriber.reconnectCount.current = 0;\n      if (subscriber.optionsRef.current.onOpen) {\n        subscriber.optionsRef.current.onOpen(event);\n      }\n\n      subscriber.setReadyState(ReadyState.OPEN);\n    });\n  };\n};\n\nconst bindCloseHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  if (webSocketInstance instanceof WebSocket) {\n    webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\n      getSubscribers(url).forEach(subscriber => {\n        if (subscriber.optionsRef.current.onClose) {\n          subscriber.optionsRef.current.onClose(event);\n        }\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      });\n      \n      delete sharedWebSockets[url];\n  \n      getSubscribers(url).forEach(subscriber => {\n        if (\n          subscriber.optionsRef.current.shouldReconnect &&\n          subscriber.optionsRef.current.shouldReconnect(event)\n        ) {\n          const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\n          if (subscriber.reconnectCount.current < reconnectAttempts) {\n            setTimeout(() => {\n              subscriber.reconnectCount.current++;\n              subscriber.reconnect.current();\n            }, subscriber.optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\n          } else {\n            subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\n            console.warn(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\n          }\n        }\n      });\n    };\n  }\n};\n\nconst bindErrorHandler = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n) => {\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\n    getSubscribers(url).forEach(subscriber => {\n      if (subscriber.optionsRef.current.onError) {\n        subscriber.optionsRef.current.onError(error);\n      }\n      if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n        subscriber.optionsRef.current.onClose && subscriber.optionsRef.current.onClose({\n          ...error,\n          code: 1006,\n          reason: `An error occurred with the EventSource: ${error}`,\n          wasClean: false,\n        });\n  \n        subscriber.setReadyState(ReadyState.CLOSED);\n      }\n    });\n    if (isEventSourceSupported && webSocketInstance instanceof EventSource) {\n      webSocketInstance.close();\n    }\n  };\n};\n\nexport const attachSharedListeners = (\n  webSocketInstance: WebSocketLike,\n  url: string,\n  optionsRef: MutableRefObject<Options>,\n  sendMessage: SendMessage,\n) => {\n  let interval: number;\n\n  if (optionsRef.current.fromSocketIO) {\n    interval = setUpSocketIOPing(sendMessage);\n  }\n\n  bindMessageHandler(webSocketInstance, url);\n  bindCloseHandler(webSocketInstance, url);\n  bindOpenHandler(webSocketInstance, url);\n  bindErrorHandler(webSocketInstance, url);\n\n  return () => {\n    if (interval) clearInterval(interval);\n  };\n};\n"]},"metadata":{},"sourceType":"script"}