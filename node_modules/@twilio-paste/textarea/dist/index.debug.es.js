var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module, temp) => {
    return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache && cache.set(module, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// esm-externals:react
var react_exports = {};
__export(react_exports, {
  default: () => default2
});
import * as default2 from "react";
import * as react_star from "react";
var init_react = __esm({
  "esm-externals:react"() {
    __reExport(react_exports, react_star);
  }
});

// esm-externals:prop-types
var prop_types_exports = {};
__export(prop_types_exports, {
  default: () => default3
});
import * as default3 from "prop-types";
import * as prop_types_star from "prop-types";
var init_prop_types = __esm({
  "esm-externals:prop-types"() {
    __reExport(prop_types_exports, prop_types_star);
  }
});

// ../../../../node_modules/autosize/dist/autosize.js
var require_autosize = __commonJS({
  "../../../../node_modules/autosize/dist/autosize.js"(exports, module) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd) {
        define(["module", "exports"], factory);
      } else if (typeof exports !== "undefined") {
        factory(module, exports);
      } else {
        var mod = {
          exports: {}
        };
        factory(mod, mod.exports);
        global.autosize = mod.exports;
      }
    })(exports, function(module2, exports2) {
      "use strict";
      var map = typeof Map === "function" ? /* @__PURE__ */ new Map() : function() {
        var keys = [];
        var values = [];
        return {
          has: function has(key) {
            return keys.indexOf(key) > -1;
          },
          get: function get(key) {
            return values[keys.indexOf(key)];
          },
          set: function set(key, value) {
            if (keys.indexOf(key) === -1) {
              keys.push(key);
              values.push(value);
            }
          },
          delete: function _delete(key) {
            var index = keys.indexOf(key);
            if (index > -1) {
              keys.splice(index, 1);
              values.splice(index, 1);
            }
          }
        };
      }();
      var createEvent = function createEvent2(name) {
        return new Event(name, { bubbles: true });
      };
      try {
        new Event("test");
      } catch (e) {
        createEvent = function createEvent2(name) {
          var evt = document.createEvent("Event");
          evt.initEvent(name, true, false);
          return evt;
        };
      }
      function assign(ta) {
        if (!ta || !ta.nodeName || ta.nodeName !== "TEXTAREA" || map.has(ta))
          return;
        var heightOffset = null;
        var clientWidth = null;
        var cachedHeight = null;
        function init() {
          var style = window.getComputedStyle(ta, null);
          if (style.resize === "vertical") {
            ta.style.resize = "none";
          } else if (style.resize === "both") {
            ta.style.resize = "horizontal";
          }
          if (style.boxSizing === "content-box") {
            heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
          } else {
            heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
          }
          if (isNaN(heightOffset)) {
            heightOffset = 0;
          }
          update2();
        }
        function changeOverflow(value) {
          {
            var width = ta.style.width;
            ta.style.width = "0px";
            ta.offsetWidth;
            ta.style.width = width;
          }
          ta.style.overflowY = value;
        }
        function getParentOverflows(el) {
          var arr = [];
          while (el && el.parentNode && el.parentNode instanceof Element) {
            if (el.parentNode.scrollTop) {
              arr.push({
                node: el.parentNode,
                scrollTop: el.parentNode.scrollTop
              });
            }
            el = el.parentNode;
          }
          return arr;
        }
        function resize() {
          if (ta.scrollHeight === 0) {
            return;
          }
          var overflows = getParentOverflows(ta);
          var docTop = document.documentElement && document.documentElement.scrollTop;
          ta.style.height = "";
          ta.style.height = ta.scrollHeight + heightOffset + "px";
          clientWidth = ta.clientWidth;
          overflows.forEach(function(el) {
            el.node.scrollTop = el.scrollTop;
          });
          if (docTop) {
            document.documentElement.scrollTop = docTop;
          }
        }
        function update2() {
          resize();
          var styleHeight = Math.round(parseFloat(ta.style.height));
          var computed = window.getComputedStyle(ta, null);
          var actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
          if (actualHeight < styleHeight) {
            if (computed.overflowY === "hidden") {
              changeOverflow("scroll");
              resize();
              actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
            }
          } else {
            if (computed.overflowY !== "hidden") {
              changeOverflow("hidden");
              resize();
              actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
            }
          }
          if (cachedHeight !== actualHeight) {
            cachedHeight = actualHeight;
            var evt = createEvent("autosize:resized");
            try {
              ta.dispatchEvent(evt);
            } catch (err) {
            }
          }
        }
        var pageResize = function pageResize2() {
          if (ta.clientWidth !== clientWidth) {
            update2();
          }
        };
        var destroy2 = function(style) {
          window.removeEventListener("resize", pageResize, false);
          ta.removeEventListener("input", update2, false);
          ta.removeEventListener("keyup", update2, false);
          ta.removeEventListener("autosize:destroy", destroy2, false);
          ta.removeEventListener("autosize:update", update2, false);
          Object.keys(style).forEach(function(key) {
            ta.style[key] = style[key];
          });
          map.delete(ta);
        }.bind(ta, {
          height: ta.style.height,
          resize: ta.style.resize,
          overflowY: ta.style.overflowY,
          overflowX: ta.style.overflowX,
          wordWrap: ta.style.wordWrap
        });
        ta.addEventListener("autosize:destroy", destroy2, false);
        if ("onpropertychange" in ta && "oninput" in ta) {
          ta.addEventListener("keyup", update2, false);
        }
        window.addEventListener("resize", pageResize, false);
        ta.addEventListener("input", update2, false);
        ta.addEventListener("autosize:update", update2, false);
        ta.style.overflowX = "hidden";
        ta.style.wordWrap = "break-word";
        map.set(ta, {
          destroy: destroy2,
          update: update2
        });
        init();
      }
      function destroy(ta) {
        var methods = map.get(ta);
        if (methods) {
          methods.destroy();
        }
      }
      function update(ta) {
        var methods = map.get(ta);
        if (methods) {
          methods.update();
        }
      }
      var autosize = null;
      if (typeof window === "undefined" || typeof window.getComputedStyle !== "function") {
        autosize = function autosize2(el) {
          return el;
        };
        autosize.destroy = function(el) {
          return el;
        };
        autosize.update = function(el) {
          return el;
        };
      } else {
        autosize = function autosize2(el, options) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], function(x) {
              return assign(x, options);
            });
          }
          return el;
        };
        autosize.destroy = function(el) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], destroy);
          }
          return el;
        };
        autosize.update = function(el) {
          if (el) {
            Array.prototype.forEach.call(el.length ? el : [el], update);
          }
          return el;
        };
      }
      exports2.default = autosize;
      module2.exports = exports2["default"];
    });
  }
});

// ../../../../node_modules/computed-style/dist/computedStyle.commonjs.js
var require_computedStyle_commonjs = __commonJS({
  "../../../../node_modules/computed-style/dist/computedStyle.commonjs.js"(exports, module) {
    var computedStyle = function(el, prop, getComputedStyle) {
      getComputedStyle = window.getComputedStyle;
      return (getComputedStyle ? getComputedStyle(el) : el.currentStyle)[prop.replace(/-(\w)/gi, function(word, letter) {
        return letter.toUpperCase();
      })];
    };
    module.exports = computedStyle;
  }
});

// ../../../../node_modules/line-height/lib/line-height.js
var require_line_height = __commonJS({
  "../../../../node_modules/line-height/lib/line-height.js"(exports, module) {
    var computedStyle = require_computedStyle_commonjs();
    function lineHeight(node) {
      var lnHeightStr = computedStyle(node, "line-height");
      var lnHeight = parseFloat(lnHeightStr, 10);
      if (lnHeightStr === lnHeight + "") {
        var _lnHeightStyle = node.style.lineHeight;
        node.style.lineHeight = lnHeightStr + "em";
        lnHeightStr = computedStyle(node, "line-height");
        lnHeight = parseFloat(lnHeightStr, 10);
        if (_lnHeightStyle) {
          node.style.lineHeight = _lnHeightStyle;
        } else {
          delete node.style.lineHeight;
        }
      }
      if (lnHeightStr.indexOf("pt") !== -1) {
        lnHeight *= 4;
        lnHeight /= 3;
      } else if (lnHeightStr.indexOf("mm") !== -1) {
        lnHeight *= 96;
        lnHeight /= 25.4;
      } else if (lnHeightStr.indexOf("cm") !== -1) {
        lnHeight *= 96;
        lnHeight /= 2.54;
      } else if (lnHeightStr.indexOf("in") !== -1) {
        lnHeight *= 96;
      } else if (lnHeightStr.indexOf("pc") !== -1) {
        lnHeight *= 16;
      }
      lnHeight = Math.round(lnHeight);
      if (lnHeightStr === "normal") {
        var nodeName = node.nodeName;
        var _node = document.createElement(nodeName);
        _node.innerHTML = "&nbsp;";
        if (nodeName.toUpperCase() === "TEXTAREA") {
          _node.setAttribute("rows", "1");
        }
        var fontSizeStr = computedStyle(node, "font-size");
        _node.style.fontSize = fontSizeStr;
        _node.style.padding = "0px";
        _node.style.border = "0px";
        var body = document.body;
        body.appendChild(_node);
        var height = _node.offsetHeight;
        lnHeight = height;
        body.removeChild(_node);
      }
      return lnHeight;
    }
    module.exports = lineHeight;
  }
});

// ../../../../node_modules/react-autosize-textarea/lib/TextareaAutosize.js
var require_TextareaAutosize = __commonJS({
  "../../../../node_modules/react-autosize-textarea/lib/TextareaAutosize.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
          if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
      }
      return t;
    };
    exports.__esModule = true;
    var React2 = (init_react(), __toCommonJS(react_exports));
    var PropTypes2 = (init_prop_types(), __toCommonJS(prop_types_exports));
    var autosize = require_autosize();
    var _getLineHeight = require_line_height();
    var getLineHeight = _getLineHeight;
    var RESIZED = "autosize:resized";
    var TextareaAutosizeClass = function(_super) {
      __extends(TextareaAutosizeClass2, _super);
      function TextareaAutosizeClass2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
          lineHeight: null
        };
        _this.textarea = null;
        _this.onResize = function(e) {
          if (_this.props.onResize) {
            _this.props.onResize(e);
          }
        };
        _this.updateLineHeight = function() {
          if (_this.textarea) {
            _this.setState({
              lineHeight: getLineHeight(_this.textarea)
            });
          }
        };
        _this.onChange = function(e) {
          var onChange = _this.props.onChange;
          _this.currentValue = e.currentTarget.value;
          onChange && onChange(e);
        };
        return _this;
      }
      TextareaAutosizeClass2.prototype.componentDidMount = function() {
        var _this = this;
        var _a = this.props, maxRows = _a.maxRows, async = _a.async;
        if (typeof maxRows === "number") {
          this.updateLineHeight();
        }
        if (typeof maxRows === "number" || async) {
          setTimeout(function() {
            return _this.textarea && autosize(_this.textarea);
          });
        } else {
          this.textarea && autosize(this.textarea);
        }
        if (this.textarea) {
          this.textarea.addEventListener(RESIZED, this.onResize);
        }
      };
      TextareaAutosizeClass2.prototype.componentWillUnmount = function() {
        if (this.textarea) {
          this.textarea.removeEventListener(RESIZED, this.onResize);
          autosize.destroy(this.textarea);
        }
      };
      TextareaAutosizeClass2.prototype.render = function() {
        var _this = this;
        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
        return React2.createElement("textarea", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight }) : style, ref: function(element) {
          _this.textarea = element;
          if (typeof _this.props.innerRef === "function") {
            _this.props.innerRef(element);
          } else if (_this.props.innerRef) {
            _this.props.innerRef.current = element;
          }
        } }), children);
      };
      TextareaAutosizeClass2.prototype.componentDidUpdate = function() {
        this.textarea && autosize.update(this.textarea);
      };
      TextareaAutosizeClass2.defaultProps = {
        rows: 1,
        async: false
      };
      TextareaAutosizeClass2.propTypes = {
        rows: PropTypes2.number,
        maxRows: PropTypes2.number,
        onResize: PropTypes2.func,
        innerRef: PropTypes2.any,
        async: PropTypes2.bool
      };
      return TextareaAutosizeClass2;
    }(React2.Component);
    exports.TextareaAutosize = React2.forwardRef(function(props, ref) {
      return React2.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));
    });
  }
});

// ../../../../node_modules/react-autosize-textarea/lib/index.js
var require_lib = __commonJS({
  "../../../../node_modules/react-autosize-textarea/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var TextareaAutosize_1 = require_TextareaAutosize();
    exports["default"] = TextareaAutosize_1.TextareaAutosize;
  }
});

// src/TextArea.tsx
var import_react_autosize_textarea = __toESM(require_lib());
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled, css } from "@twilio-paste/styling-library";
import { safelySpreadBoxProps, getCustomElementStyles } from "@twilio-paste/box";
import { InputBox } from "@twilio-paste/input-box";
var TextAreaElement = styled(import_react_autosize_textarea.default)((props) => css({
  appearance: "none",
  background: "transparent",
  border: "none",
  borderRadius: "borderRadius20",
  boxShadow: "none",
  color: "inherit",
  display: "block",
  fontFamily: "inherit",
  fontSize: "fontSize30",
  fontWeight: "fontWeightMedium",
  lineHeight: "lineHeight20",
  maxHeight: "size30",
  outline: "none",
  paddingBottom: "space30",
  paddingLeft: "space40",
  paddingRight: "space40",
  paddingTop: "space30",
  resize: "vertical",
  width: "100%",
  "&::placeholder": {
    color: props.variant === "inverse" ? "colorTextInverseWeak" : "colorTextWeak",
    fontStyle: "italic"
  },
  "&:focus::placeholder": {
    color: props.variant === "inverse" ? "colorTextInverseWeak" : "colorTextWeak"
  },
  "&:disabled": {
    color: props.variant === "inverse" ? "colorTextInverseWeaker" : "colorTextWeaker",
    cursor: "not-allowed",
    "-webkit-text-fill-color": props.variant === "inverse" ? "colorTextInverseWeaker" : "colorTextWeaker",
    "-webkit-opacity": "1"
  }
}), getCustomElementStyles);
var TextArea = React.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    disabled,
    element = "TEXTAREA",
    hasError,
    insertBefore,
    insertAfter,
    readOnly,
    variant,
    size,
    height,
    width
  } = _b, props = __objRest(_b, [
    "children",
    "disabled",
    "element",
    "hasError",
    "insertBefore",
    "insertAfter",
    "readOnly",
    "variant",
    "size",
    "height",
    "width"
  ]);
  return /* @__PURE__ */ React.createElement(InputBox, {
    disabled,
    element,
    hasError,
    insertAfter,
    insertBefore,
    readOnly,
    variant
  }, /* @__PURE__ */ React.createElement(TextAreaElement, __spreadProps(__spreadValues({}, safelySpreadBoxProps(props)), {
    async: true,
    "aria-invalid": hasError,
    "aria-readonly": readOnly,
    disabled,
    "data-paste-element": `${element}_ELEMENT`,
    readOnly,
    ref,
    rows: 3,
    spellCheck: true,
    variant
  }), children));
});
TextArea.displayName = "TextArea";
TextArea.propTypes = {
  disabled: PropTypes.bool,
  element: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  onFocus: PropTypes.func,
  placeholder: PropTypes.string,
  readOnly: PropTypes.bool,
  required: PropTypes.bool
};
export {
  TextArea
};
/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/
